seg_temp = filter(droso_gap_bin, time == 1 & AP >= x & AP < x +10)
seg_label = c(seg_label, rep(AP_label[x/10 + 1], dim(seg_temp)[1]))
}
droso_gap_bin = mutate(droso_gap_bin, "manual_seg" = rep(seg_label, 8))
ggplot(droso_gap_bin, aes(x = gt, y = kr)) +
geom_point() +
facet_grid(manual_seg ~ time) +
ggtitle("gt vs kr in time with manual segmentation binned data set ") +
theme(text = element_text(size = 15))
ggplot(droso_gap_bin, aes(x = kni, y = hb)) +
geom_point() +
facet_grid(manual_seg ~ time) +
ggtitle("kni vs hb in time with manual segmentation binned data set ") +
theme(text = element_text(size = 15))
# -----------------------------------------------------------------------------------------------------
# Implement Clustering Analysis Methods: k-mean , kernel k-mean(nonlinear)
# -----------------------------------------------------------------------------------------------------
# output "droso_gap_bin" into a csv file
# write_csv(droso_gap_bin, path = "gap_gene_intensity")
# implement k-mean
model_km3 = kmeans(droso_gap_bin[,c(-6,-7)], centers =3)
droso_km3 = mutate(droso_gap_bin, "cluster" = model_km3$cluster)
# --------------------------------------
# implement kernel k-mean
model_kkm3 = kkmeans(as.matrix(droso_gap_bin[, c(-6,-7)]), centers = 3) # kkmeans only takes in matrix/list data type
droso_kkm3 = mutate(droso_gap_bin, "cluster" = model_kkm3)
#3D plot for the clustered data through all time.
km_3D <- plot_ly(droso_kkm3, x = ~AP, y = ~gt, z = ~kr,
marker = list(size = 2, color = ~as.factor(cluster), showscale = TRUE)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'AP'),
yaxis = list(title = 'gt intensity'),
zaxis = list(title = 'kr intensity')),
annotations = list(
x = 1.15,
y = 1.05,
text = 'cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
# 2D plot of the cluster results
ggplot(droso_kkm3, aes(x = AP , y = gt, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("AP") +
ylab("gt") +
ggtitle("Kernel k-mean(k=3) [include AP info] AP vs gt Intensity") +
theme(text = element_text(size = 20))
# -------------------------------
# perform simulation with kernel kmean result at time 4
# -------------------------------
kkm3_t4_c1 = filter(droso_kkm3, time == 4 & cluster == 1)
kkm3_t4_c2 = filter(droso_kkm3, time == 4 & cluster == 2)
kkm3_t4_c3 = filter(droso_kkm3, time == 4 & cluster == 3)
#########################################################################################
# V.  Time Delay :
#########################################################################################
time_label = c('1-2', '2-3', '3-4', '4-5', '5-6', '6-7', '7-8')
gene_lag  = data.frame()
gene = c('gt', 'kr', 'kni', 'hb')
for (g in gene){
for (t in 1:7){
gene_t1 = filter(droso_gap_bin, time == t)[g]
gene_t2 = filter(droso_gap_bin, time == t+1)[g]
gene_temp = data.frame(gene_t1, gene_t2, rep(time_label[t], 95), rep(g, 95))
colnames(gene_temp) = c('time1', 'time2', 'time_label', 'gene')
gene_lag = rbind(gene_lag, gene_temp)
}
}
ggplot(gene_lag, aes(x = time1, y = time2))+
geom_point(alpha = 0.8) +
facet_grid(time_label~gene) +
xlab("Time (t)") +
ylab("Time (t + 1)") +
ggtitle("Time Delayed(lag by 1)") +
theme(text = element_text(size = 15))
glimpse(kkm3_t4_c1)
kkm3_t4_c1
kkm3_t4_c2
kkm3_t4_c3
cluster1_1_trans_state = Spacial_Trans_Prob(droso_Boolean, 4, 23)[[1]]
cluster2_1_trans_state = Spacial_Trans_Prob(droso_Boolean, 24, 39)[[1]]
cluster1_2_trans_state = Spacial_Trans_Prob(droso_Boolean, 40, 46)[[1]]
cluster2_2_trans_state = Spacial_Trans_Prob(droso_Boolean, 47, 69)[[1]]
cluster3_trans_state = Spacial_Trans_Prob(droso_Boolean, 70, 98)[[1]]
cluster1_1_tp = Spacial_Trans_Prob(droso_Boolean, 4, 23)[[2]]
cluster2_1_tp = Spacial_Trans_Prob(droso_Boolean, 24, 39)[[2]]
cluster1_2_tp = Spacial_Trans_Prob(droso_Boolean, 40, 46)[[2]]
cluster2_2_tp = Spacial_Trans_Prob(droso_Boolean, 47, 69)[[2]]
cluster3_tp = Spacial_Trans_Prob(droso_Boolean, 70, 98)[[2]]
cluster1_1_tp_counter = Spacial_Trans_Prob(droso_Boolean, 4, 23)[[3]]
cluster2_1_tp_counter = Spacial_Trans_Prob(droso_Boolean, 24, 39)[[3]]
cluster1_2_tp_counter = Spacial_Trans_Prob(droso_Boolean, 40, 46)[[3]]
cluster2_2_tp_counter = Spacial_Trans_Prob(droso_Boolean, 47, 69)[[3]]
cluster3_tp_counter = Spacial_Trans_Prob(droso_Boolean, 70, 98)[[3]]
cluster1_2
cluster1_2_tp
c1_1_sim = Spacial_Sim(cluster1_1_trans_state, tp = cluster1_1_tp, 4, 23)
c2_1_sim = Spacial_Sim(cluster2_1_trans_state, tp = cluster2_1_tp, 24, 39)
c1_2_sim = Spacial_Sim(cluster1_2_trans_state, tp = cluster1_2_tp, 40, 46)
c2_2_sim = Spacial_Sim(cluster2_2_trans_state, tp = cluster2_2_tp, 47, 69)
c3_sim = Spacial_Sim(cluster3_trans_state, tp = cluster3_tp, 70, 98)
droso_sim_100 = Spacial_Sim(full_trans_state,tp = full_tp, nn, 4, 98)
c1_1_sim = Spacial_Sim(cluster1_1_trans_state, tp = cluster1_1_tp, 4, 23)
c1_1_sim = Spacial_Sim(cluster1_1_trans_state, tp = cluster1_1_tp, nn, 4, 23)
c2_1_sim = Spacial_Sim(cluster2_1_trans_state, tp = cluster2_1_tp, nn, 24, 39)
c1_2_sim = Spacial_Sim(cluster1_2_trans_state, tp = cluster1_2_tp, nn, 40, 46)
c2_2_sim = Spacial_Sim(cluster2_2_trans_state, tp = cluster2_2_tp, nn, 47, 69)
c3_sim = Spacial_Sim(cluster3_trans_state, tp = cluster3_tp, nn, 70, 98)
all_cluster = data.frame(rbind(filter(c1_1_sim, time == 1), filter(c2_1_sim, time == 1),
filter(c1_2_sim, time == 1),filter(c2_2_sim, time == 1), filter(c3_sim, time == 1)))
for (t in 2:8){
all_cluster = rbind(all_cluster,(rbind(filter(c1_1_sim, time == t), filter(c2_1_sim, time == t),
filter(c1_2_sim, time == t),filter(c2_2_sim, time == t), filter(c3_sim, time == t))))
}
colnames(all_cluster) = c("AP", 'time', 'gt_avg_cl', 'kr_avg_cl', 'kni_avg_cl', 'hb_avg_cl') # relabeling
# visulization the simulation results:
sim_long = gather(all_cluster, key = 'gene', value = 'avg_prob', gt_avg_cl:hb_avg_cl)
ggplot(sim_long, aes(x = AP, y = avg_prob)) +
geom_line() +
facet_grid(time ~ gene) +
ylab('Avg Probabilities') +
xlab("AP position") +
ggtitle('3rd Clustering Simulation Results for n = 100') +
theme(text = element_text(size = 20))
droso_compare_prob = droso_sim_100 %>%
cbind(all_cluster[, c('gt_avg_cl', 'kr_avg_cl', 'kni_avg_cl', 'hb_avg_cl')]) %>%
cbind(WT_prob[, c('gt', 'kr', 'kni', 'hb')]) %>%
gather(key = 'gene', value = 'value', gt_avg:hb) %>%
mutate('source' = source, 'gene_label' = gene_label)
ggplot(droso_compare_prob, aes(x = AP, y = value)) +
geom_line(alpha = 0.8, aes(linetype = source)) +
facet_grid(time~gene_label) +
scale_linetype_manual(values=c("twodash", "dotted", "solid")) +
xlab("AP position") +
ylab("Probability") +
ggtitle("Simulation vs Experimental in Prob N = 100") +
theme(text = element_text(size = 20))
install.packages("factoextra")
library("factoextra") # multivariable analysis in R [hkmean]
args(hkmeans)
?hkmeans
km_df = droso_gap_bin[ , c(-6, -7)]
km_df
glimpse(km_df)
args(scale)
?scale
test = scale(km_df)
test
km_df = scale(droso_gap_bin[ , c(-6, -7)]) # scale the df for clustering purpose
km_df
args(hkmeans)
# implement Hierachical k-mean: an optimized version for k-mean
model_hkm = hkmeans(km_df, k = 3)
model_hkm
names(model_hkm)
model_hkm$centers
model_hkm$data
model_hkm$tot.withinss
args(fviz_dend)
?fviz
# visualize the dendrogram/tree
fviz_dend(model_hkm)
install.packages("dendextend")
library("dendextend") # create dendrogram object for hclustering plot
install.packages("mclust")
install.packages("mclust")
library("dendextend") # create dendrogram object for hclustering plot
install.packages("dendextend")
install.packages("mclust")
library("dendextend") # create dendrogram object for hclustering plot
# visualize the dendrogram/tree
fviz_dend(model_hkm)
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
fviz_cluster(model_hkm, palette = "jco", repel = TRUE,
ggtheme = theme_classic())
fviz_cluster(model_hkm, palette = "jco", repel = TRUE,
ggtheme = theme_classic())
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
model_hkm$cluster
droso_hkm = mutate(droso_gap_bin, "cluster" = model_hkm$cluster)
glimpse(droso_hkm)
ggplot(droso_hkm, aes(x = AP , y = gt, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("AP") +
ylab("gt") +
ggtitle("Hierachiechal k-mean(k=3) [include AP info] AP vs gt Intensity") +
theme(text = element_text(size = 20))
ggplot(droso_hkm, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("gt") +
ylab("kr") +
ggtitle("Hierachiechal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
model_hkm = hkmeans(km_df, k = 2)
droso_hkm = mutate(droso_gap_bin, "cluster" = model_hkm$cluster)
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
ggplot(droso_hkm, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("gt") +
ylab("kr") +
ggtitle("Hierachiechal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
# 2D plot of the cluster results
ggplot(droso_hkm, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Hierachiechal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
library("dendextend")          # dendrogram coloring and labeling
install.packages("cluster")
library("cluster")             # silhouette calculation to determine value for k
install.packages("dendextend")
install.packages('dendextendRcpp')
install.packages("devtools")
devtools::install_github('talgalili/dendextend')
devtools::install_github('talgalili/dendextend')
install.packages("mclust")
install.packages("dendextend")
install.packages("mclust")
km_df = scale(droso_gap_bin[ , c(-6, -7)]) # scale the df for clustering purpose
model_km3 = kmeans(km_df, centers =3)
droso_km3 = mutate(droso_gap_bin, "cluster" = model_km3$cluster)
ggplot(droso_km3, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
km_df = scale(droso_gap_bin[ , c(-6, -7)]) # scale the df for clustering purpose
# implement k-mean
model_km = kmeans(km_df, centers =2)
droso_km = mutate(droso_gap_bin, "cluster" = model_km3$cluster)
ggplot(droso_km3, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
ggplot(droso_km, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
km_df = scale(droso_gap_bin[ , c(-6, -7)]) # scale the df for clustering purpose
# implement k-mean
model_km = kmeans(km_df, centers =2)
droso_km = mutate(droso_gap_bin, "cluster" = model_km$cluster)
ggplot(droso_km, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
args(as.dendrogram)
args(cutree)
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_kmm)
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
km_elbow
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20)
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
args(pam)
?pam
library('cluster')
sil_width = map_dbl(2:20, function(k){
pam_km = pam(km_df, k = k)
pam_km$silinfo$avg.width
})
sil_df = data.frame('k' = 2:20, 'avg_sil_width' = sil_width)
ggplot(sil_df, aes(x = k, y = avg_sil_width)) +
ggtitle("silhouette plot for gene:gene LRR") +
geom_line() +
scale_x_continuous(breaks = 2:20)
ggplot(sil_df, aes(x = k, y = avg_sil_width)) +
ggtitle("silhouette plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 2:20) +
theme(text = element_text(size = 20))
model_km = kmeans(km_df, centers =5)
droso_km = mutate(droso_gap_bin, "cluster" = model_km$cluster)
ggplot(droso_km, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean(k=3) [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
ggplot(droso_km, aes(x = AP , y = gt, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("AP") +
ylab("gt") +
ggtitle("Normal k-mean [include AP info] AP vs gt Intensity") +
theme(text = element_text(size = 20))
model_hkm = hkmeans(km_df, k = 5)
droso_hkm = mutate(droso_gap_bin, "cluster" = model_hkm$cluster)
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
total_withinSS_km = map_dbl(1:20, function(k){
model_km = hkmeans(km_df, centers = k)
model_km$tot.withinss
})
args(hkmeans)
total_withinSS_km = map_dbl(1:20, function(k){
model_km = hkmeans(km_df, k = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 3 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 3 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
set.seed(28)
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
set.seed(28)
# first determine the optimize k-value for the data based on elbow and silhouette method
# use elbow on regular k-mean
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 2 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 2 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
set.seed(28)
# first determine the optimize k-value for the data based on elbow and silhouette method
# use elbow on regular k-mean
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 2 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
set.seed(78)
# first determine the optimize k-value for the data based on elbow and silhouette method
# use elbow on regular k-mean
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 2 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
total_withinSS_km = map_dbl(1:20, function(k){
model_km = kmeans(km_df, centers = k)
model_km$tot.withinss
})
km_elbow = data.frame( 'k' = 1:20, 'tot_withinSS' = total_withinSS_km)
# the plot implies k = 2 as the optimized value
ggplot(km_elbow, aes(x = k, y = tot_withinSS)) +
ggtitle("elbow plot for gene intensity") +
geom_line() +
scale_x_continuous(breaks = 1:20) +
theme(text = element_text(size = 20))
args(fanny)
?fanny
# implement Fuzzy clustering: fuzzy c-mean (FCM)
model_fcm = fanny(km_df, k = 3)
# implement Fuzzy clustering: fuzzy c-mean (FCM)
model_fcm = fanny(km_df, k = 3, metric = "euclidean", stand = FALSE)
model_fcm
model_fcm$membership
model_fcm$coeff
model_fcm$objective
model_fcm$convergence
model_fcm$clustering
droso_fcm = mutate(droso_gap_bin, "cluster" = model_fcm$clustering)
fviz_cluster(model_fcm)
model_hkm = hkmeans(km_df, k = 3)
droso_hkm = mutate(droso_gap_bin, "cluster" = model_hkm$cluster)
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
ggplot(droso_fcm, aes(x = AP , y = gt, color = factor(cluster))) +
geom_point(alpha =0.6) +
xlab("AP") +
ylab("gt") +
ggtitle("Fuzzy c-means AP vs gt Intensity") +
theme(text = element_text(size = 20))
ggplot(droso_km, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Normal k-mean [include AP info] gt vs kr Intensity") +
theme(text = element_text(size = 20))
ggplot(droso_fcm, aes(x = gt , y = kr, color = factor(cluster))) +
geom_point(alpha =0.6) +
facet_wrap(~time, nrow =2 ) +
xlab("gt") +
ylab("kr") +
ggtitle("Fuzzy c-means gt vs kr Intensity") +
theme(text = element_text(size = 20))
install.packages("fpc")
library("mclust")
install.packages("deadband")
library("dendextend") # create dendrogram object for hclustering plot
install.packages("dendextend")
library("dendextend") # create dendrogram object for hclustering plot
install.packages("fpc")
install.packages("fpc")
library("fpc") # Density-Based Spatial Clustering and application with Noise
install.packages("dbscan")
library("dbscan")# Density-Based Spatial Clustering and application with Noise
# visualize the dendrogram/tree
fviz_dend(model_hkm)
# implement density-based spatial clustering and application with noise(DBSCAN)
# 1. need to first find the optimized epsilon-value and minimum points
dbscan::kNNdistplot(km_df, k = 5)
# implement density-based spatial clustering and application with noise(DBSCAN)
# 1. need to first find the optimized epsilon-value and minimum points
dbscan::kNNdistplot(km_df, k = 3)
# implement density-based spatial clustering and application with noise(DBSCAN)
# 1. need to first find the optimized epsilon-value and minimum points
dbscan::kNNdistplot(km_df, k = 10)
# implement density-based spatial clustering and application with noise(DBSCAN)
# 1. need to first find the optimized epsilon-value and minimum points
dbscan::kNNdistplot(km_df, k = 5)
dbscan::kNNdistplot(km_df, k = 5)
abline(h = 0.5, lty = 2)
# 2. build the density-based cluster model
model_db = fpc::dbscan(km_df, eps = 0.5, MinPts = 5)
args(dbscan)
?dbscan
model_db
names(model_db)
fviz_cluster(model_db)
library("factoextra") # multivariable analysis in R [hkmean]
# 2. build the density-based cluster model
model_db = fpc::dbscan(km_df, eps = 0.5, MinPts = 5)
# visualize the dendrogram/tree
fviz_cluster(model_hkm)
# visualize the dendrogram/tree
fviz_dend(model_hkm)
fviz_cluster(model_db)
fviz_cluster(model_db, data = km_df)
model_db
model_db$cluster
# 2. build the density-based cluster model
model_db = fpc::dbscan(km_df, eps = 0.15, MinPts = 5)
model_db
model_db
model_db$cluster
